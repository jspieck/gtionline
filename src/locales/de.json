{
  "complementExample": "Komplementsrechnung",
  "shiftZero": "Mantissennull nach Shift",
  "doubleNegative": "Negativ",
  "denormalized": "Denormalisierung",
  "fpExerciseIntro": "Üben Sie die Gleitkommazahlen Arithmetik nach IEEE-754 anhand automatisch generierter Aufgaben.",
  "fpFormatSelectionSimple": "Wählen Sie die Anzahl der Bits für den Exponenten und die Mantisse aus.",
  "fpFormatSelection": "Definieren Sie die Bitbreite der Gleitkommazahl und wählen Sie dann die Anzahl der Bits für den Exponenten und die Mantisse aus.",
  "fpArithIntro": "Üben Sie die Gleitkommazahlen Arithmetik nach IEEE-754 oder einem daran angelehnten selbstdefinierten Format.",
  "fpConvIntro": "Üben Sie die Konversion zwischen dem Dezimalsystem und dem Gleitkommazahl Format nach IEEE-754 oder einem daran angelehnten selbstdefinierten Format anhand generierter Übungsaufgaben.",
  "sequentialCircuit": "Beispiel eines Schaltwerks bestehend aus zwei D-Flipflops und mehreren Multiplexern.",
  "polyadicDivisionDescription": "Die Vorkommastellen ergeben sich aus den Ziffern des Rests, indem man diese von unten nach oben ausliest.",
  "polyadicMultiplicationDescription": "Die Nachkommastellen ergeben sich aus den Ziffern des Rests, indem man diese von oben nach unten ausliest.",
  "homePageText": "Auf dieser Webseite können Sie Ihre Kenntnisse zu ausgewählten Themenschwerpunkten aus der Vorlesung Grundlagen der Technischen Informatik (GTI) und der zugehörigen Übung vertiefen.",
  "startTraining": "Los geht's",
  "polyFreeIntro": "Üben Sie die polyadische Arithmetik mit eigenen Zahlenwerten in Ihrem Wunschsystem.",
  "polyConvGenIntro": "Üben Sie die Konversion zwischen polyadischen Systemen anhand generierter Übungsaufgaben.",
  "polyConvIntro": "Üben Sie die Konversion zwischen polyadischen Systemen, die Sie frei auswählen können.",
  "numVarInput": "Anzahl an Variablen",
  "conversionExercise": "Aufgaben zur Konversion",
  "impressum": "Impressum",
  "copyright": "Lehrstuhl für Informatik 12, FAU. Alle Rechte vorbehalten.",
  "herausgeber": "Herausgeber",
  "disclaimerFooter": "Es wird keine Garantie für die Richtigkeit der auf dieser Website angebotenen Materialien übernommen.",
  "representedByHeader": "Vertreten durch",
  "contactPersonHeader": "Kontakt",
  "representedBy": "Lehrstuhl für Informatik 12 ist eine Einrichtung des Öffentlichen Rechts innerhalb der Friedrich-Alexander-Universität Erlangen-Nürnberg (FAU). Gemäß Art. 20, 21 BayHSchG wird die FAU als staatliche Einrichtung und Selbstverwaltungskörperschaft des öffentlichen Rechts nach außen durch den Präsidenten vertreten.",
  "haftungsauschlussHeader": "Haftungsausschluss",
  "haftungsauschlussBody": "Für die Inhalte anderer Webangebote sind die jeweiligen Einrichtungen verantwortlich. Alle auf dieser Internetseite bereitgestellten Informationen haben wir nach bestem Wissen und Gewissen erarbeitet und geprüft. Eine Gewähr für die jederzeitige Aktualität, Richtigkeit, Vollständigkeit und Verfügbarkeit der bereit gestellten Informationen können wir allerdings nicht übernehmen. Ein Vertragsverhältnis mit den Nutzern des Internetangebots kommt nicht zustande. Wir haften nicht für Schäden, die durch die Nutzung dieses Internetangebots entstehen. Dieser Haftungsausschluss gilt nicht, soweit die Vorschriften des §839 des Bürgerlichen Gesetzbuches (Haftung bei Amtspflichtverletzung) einschlägig sind. Für etwaige Schäden, die beim Aufrufen oder Herunterladen von Daten durch Schadsoftware oder der Installation oder Nutzung von Software verursacht werden, wird nicht gehaftet. Als Diensteanbieter sind wir gemäß § 7 Abs.1 TMG für eigene Inhalte auf diesenSeiten nach den allgemeinen Gesetzen verantwortlich. Nach § 8 bis 10 TMG sind wir als Diensteanbieter jedoch nicht verpflichtet, übermittelte oder gespeicherte fremde Informationen zu überwachen oder nach Umständen zu forschen, die auf eine rechtswidrige Tätigkeit hinweisen. Verpflichtungen zur Entfernung oder Sperrung der Nutzung von Informationen nach den allgemeinen Gesetzen bleiben hiervon unberührt. Eine diesbezügliche Haftung ist jedoch erst ab dem Zeitpunkt der Kenntnis einer konkreten Rechtsverletzung möglich. Bei Bekanntwerden von entsprechenden Rechtsverletzungen werden wir diese Inhalte umgehend entfernen. Der Betreiber behält es sich ausdrücklich vor, einzelne Webseiten, Web-Dienste oder das gesamte Angebot ohne gesonderte Ankündigung zu verändern, zu ergänzen, zu löschen oder die Veröffentlichung zeitweise oder endgültig einzustellen.",
  "confirm": "Bestätigen",
  "varNaming": "Benennung der Variablen",
  "kvDiagram": "KV-Diagramm",
  "truthtable": "Funktionstabelle",
  "numeralSystem": "Zahlensysteme",
  "polyadic": "Polyadisch",
  "floatingPoint": "Gleitkommazahlen",
  "functionMin": "Funktionsminimierung",
  "exercises": "Übungsaufgaben",
  "generateEx": "Aufgabe Generieren",
  "generate": "Generieren",
  "addition": "Addition",
  "subtraction": "Subtraktion",
  "multiplication": "Multiplikation",
  "division": "Division",
  "ownSolution": "Eigene Lösung",
  "signBit": "Vorzeichenbit",
  "correctSolution": "Lösungsweg",
  "solution": "Lösung",
  "exponentBits": "Exponent",
  "fractionBits": "Mantisse",
  "attRound": "Runden nicht vergessen!",
  "attSolve": "Bitte versuchen Sie, die Aufgabe vorher selbstständig zu lösen!",
  "step": "Schritt",
  "freeCalculation": "Freie Berechnung",
  "operationSelect": "Operationsauswahl",
  "firstFloatingPoint": "Erste Gleitkommazahl",
  "secondFloatingPoint": "Zweite Gleitkommazahl",
  "operand": "Operand",
  "decimal": "Dezimalzahl",
  "binary": "Binärzahl",
  "inputNumber": "Zahl eingeben",
  "fpformat": "Floating Point Format",
  "check": "Überprüfen",
  "values": "Werte",
  "load": "Laden",
  "arithmetic": "Arithmetik",
  "conversion": "Konversion",
  "conversionExercise1": "Konvertiere: ",
  "conversionExercise2": "in eine IEEE-Gleitkommazahl einer Exponenten-Länge von ",
  "steps": "Schritte",
  "repeatMinuend": "wiederhole\\ Minuend",
  "doDivision": "Divison durchführen",
  "doMultiplication": "Multiplikation durchführen",
  "getDescription": "Drucken",
  "approach": "Lösungsweg",
  "gti": "Grundlagen der Technischen Informatik",
  "disclaimer": "Haftungsausschluss:<br>Dies ist ein durch die GTI-Online-Webseite automatisch generierter Lösungsweg. Wir können keine Korrektheit garantieren und der Lösungsvorschlag ist somit <u>inoffiziell</u>.<br>Wir geben uns große Mühe, um für euch ein zuverlässiges und korrektes Hilfsmittel zu entwickeln. Trotzdem kann es sein, dass der Lösungsweg oder die Lösung per se Fehler enthalten. Dies kann auch mit bestimmten Browserversionen zusammenhängen. Bitte überprüfen Sie den Lösungsansatz, bevor Sie diesen zum Beispiel in einer Klausur verwenden.",
  "example": "Beispiel",
  "composition": "Zusammensetzung",
  "negativeSummand": "Eine Addition mit einem negativen Wert wird wie eine Subtraktion behandelt.",
  "negativeSubtrahend": "Ein negativer Subtrahend wirkt sich wie ein positiver Summand aus.",
  "negativeMinuendSubtrahend": "Vereinfachung für den Fall \\( - x - y \\rightarrow - (x + y) \\)",
  "addWithZero": "Bei einer Addition mit 0 wird der andere Summand nicht verändert",
  "subWithZero": "Bei einer Subtraktion mit 0 wird der Minuend nicht verändert",
  "divWithZero": "Bei einer Division mit 0 im Zähler ist das Ergebnis 0.",
  "mulWithZero": "Bei einer Multiplikation mit 0 ist das Ergebnis immer 0.",
  "zeroDivision": "Eine Division durch 0 ist nicht möglich!",
  "arithmeticFree": "Freie Arithmetik",
  "conversionFree": "Freie Konvertierung",
  "value": "Wert",
  "givenValues": "Werte der übertragenen Zahlen",
  "leftValue": "Zahl links",
  "rightValue": "Zahl rechts",
  "firstSummand": "1. Summand",
  "secondSummand": "2. Summand",
  "firstFactor": "1. Faktor",
  "secondFactor": "2. Faktor",
  "numerator": "Zähler",
  "denominator": "Nenner",
  "minuend": "Minuend",
  "subtrahend": "Subtrahend",
  "sign": "Vorzeichen",
  "exponent": "Exponent",
  "adjustExponents": "Die Exponenten beider Zahlen müssen angeglichen werden.",
  "addExponents": "Die Exponenten beider Zahlen müssen addiert werden.",
  "subtExponents": "Die Exponenten beider Zahlen müssen subtrahiert werden.",
  "diffExponent": "Differenz Exponent",
  "smallerExponent": "Es wird immer der kleinere vom größeren Exponenten subtrahiert.",
  "resDiffExponent": "Daher ergibt sich eine Differenz von",
  "newExponentDivision": "Der neue Exponent ergibt sich als \\( E_{'{neu}'} = E_1 - E_2 + BIAS = {E1} - {E2} + {Bias} = {Result} \\)",
  "newExponentMultiplication": "Der neue Exponent ergibt sich als \\( E_{'{neu}'} = E_1 + E_2 - BIAS = {E1} + {E2} - {Bias} = {Result}\\, ({ExpBits})\\)",
  "considerExponent": "Exponent beachten",
  "fpExerciseText": "Es seien die Gleitkommazahlen \\( fp_1 \\) und \\( fp_2 \\) im 16 Bit Gleitkommaformat gegeben. Berechnen Sie die {op1} \\( fp_1 {op2} fp_2 \\) ohne die Binärdarstellung zu verlassen und geben Sie das Ergebnis wieder als Gleitkommazahl an:",
  "mantissa": "Mantisse",
  "solutionIsNan": "Die Mantisse muss nicht berechnet werden, da das Ergebnis sicher NaN ist.",
  "solutionIsInf": "Die Mantisse muss nicht berechnet werden, da das Ergebnis sicher unendlich ist.",
  "solutionIsZero": "Die Mantisse muss nicht berechnet werden, da das Ergebnis sicher 0 ist.",
  "mulMantissa": "Die Mantissen beider Zahlen müssen multipliziert werden.",
  "addMantissa": "Die Mantissen beider Zahlen müssen addiert werden.",
  "divMantissa": "Die Mantissen beider Zahlen müssen dividiert werden.",
  "newMantissa": "Neue Mantisse",
  "zeroMantissa": "Mantissen sind identisch \\( \\rightarrow \\) neue Mantissa ist 0-Mantisse",
  "newMantissaIs": "Wir rechnen also",
  "newMantissaSignBit": "Aufgrund des Komplements rechnen wir mit einem Vorzeichenbit:",
  "equalMantissa": "Die Mantissen sind identisch, \\( \\rightarrow \\) Exponent wird um 1 erhöht; die Mantisse bleibt gleich",
  "equalMantissaDiv": "Die beiden Mantissen sind gleich, daher wird keine binäre Division durchgeführt. Die Mantisse lautet {Mantissa}.",
  "adjustSmallerMantissa": "Anpassen der Mantisse",
  "shiftMantissa": "Shiften der Mantisse",
  "mantissaFloat": "Mantisse im Float",
  "mantissaNormalize": "Damit die Mantisse mit einer führenden 1 beginnt, müssen wir die Mantisse normalisieren, indem wir den Shift von {shift} anwenden. Diesen Shift müssen wir auch auf den Exponenten verrechnen, wodurch sich der neue Exponent {exponent} ergibt",
  "mantissaNormalizeDenorm": "Das Ergebnis kann mit dem Shift {shift} nicht in der normalisierten Darstellung dargestellt werden, weshalb wir die denormalisierte Darstellung mit dem Exponenten {exponent} verwenden.",
  "mantissaDenormalize": "Da wir nach dem Anwenden des Shifts einen negativen Exponenten bekommen, müssen wir zur Darstellung des Ergebnisses die denormalisierte Darstellung verwenden. Dazu setzen wir den Exponenten vollständig auf 0 und shiften unsere Mantisse inklusive der führenden Eins um den Betrag des Exponenten. Bei der Mantisse wird hierbei eine führende 0 angenommen.",
  "mantissa1float": "Schließlich entfernen wir die führende Stelle der Mantisse, um die Mantissenbits der IEEE-754 Repräsentation zu erhalten. Die Mantissenbits lauten demnach:",
  "mantissaComplement": "Die Mantisse ist negativ. Wir müssen also das Komplement bilden und das Vorzeichenbit setzen.",
  "subtTwosComplement": "Subtraktion entspricht der Addition mit dem Zweierkomplement",
  "mantissaTwosComplement": "Bildung Zweierkomplement aus Mantisse",
  "switchBits": "Bits umkehren",
  "add1": "1 addieren",
  "normalize": "Normalisieren",
  "shiftExpMant": "Der Shift-Faktor des Exponenten muss auf die Mantissen angewendet werden.",
  "shift": "Shift",
  "considerRepresentation": "Darstellung beachten",
  "consider1comma": "Die Mantisse beginnt in der Standard-Darstellung immer mit einer 1 vor dem Komma (und einer 0, wenn denormalisiert).",
  "ternary": "Ternärzahl",
  "quaternary": "Quaternärzahl",
  "quinary": "Quintalzahl",
  "senary": "Hexalzahl",
  "septenary": "Heptalsystem",
  "octal": "Oktalzahl",
  "novenary": "Nonalzahl",
  "hexadecimal": "Hexadezimalzahl",
  "hex": "Hexadezimal",
  "input": "Eingabe",
  "number": "Nummer",
  "representation": "Repräsentation im Ausgangsformat",
  "firstFormat": "Ausgangsformat",
  "secondFormat": "Zielformat",
  "doConversion": "Konvertierung durchführen:",
  "modus": "Modus",
  "to": "nach",
  "fp_from_archive": "Aus Übungsarchiv",
  "TenToPower": "Bei der Konvertierung vom Dezimalsystem in ein anderes polyadisches System wird vor dem Komma der Divisions- und nach dem Komma der Multiplikationsalgorithmus angewendet.",
  "PowerToTen": "Die Konvertierung eines beliebigen Systems in das Dezimalsystem läuft durch Summierung der potenzierten Stellen.",
  "PowerToPower": "Die Konvertierung einer Zahl eines Zahlensystems in ein anderes Zahlensystem erfolgt in zwei Schritten. Zuerst wird die Zahl des ursprünglichen Systems durch Aufsummieren in das Dezimalsystem übertragen. Danach wird diese Dezimalzahl mittels sukzessiver Division der Vorkommastellen und sukzessiver Multiplikation der Nachkommastellen ins Zielsystem konvertiert.",
  "noValuesBeforeComma": "Keine Werte vor dem Komma. Der Divisionsalgorithmus kann weggelassen werden",
  "noValuesAfterComma": "Keine Werte nach dem Komma. Der Multiplikationssalgorithmus kann weggelassen werden",
  "firstToTen": "1. Summieren der potenzierten Stellen",
  "secondToPower": "2. Konvertierung mittels Divisions- und Multiplikationsalgorithmus",
  "shortcutBinToHex": "Bei der Konvertierung von Binär nach Hex können die Werte direkt abgelesen werden.",
  "shortcutHexToBin": "Bei der Konvertierung von Hex nach Binär können die Werte direkt abgelesen werden.",
  "divisionAlgorithm": "Ganzzahliger Teil (Divisions-Algorithmus)",
  "multiplicationAlgorithm": "Nachkommastellen (Multiplikations-Algorithmus)",
  "summation": "Aufsummieren",
  "factor": "Faktor",
  "quotient": "Quotient",
  "remainder": "Rest",
  "newBasis": "Basis_{'{neu}'}",
  "calcStep": "Rechenschritt",
  "summands": "Summanden",
  "polyadicExercise1": "Konvertiere die",
  "polyadicExercise3": "in eine ",
  "archive": "Archiv",
  "exerciseArchive": "Aufgabenarchiv",
  "randomExercise": "Zufällige Aufgabe",
  "doCalculation": "Berechnen",
  "colorCoding": "Farbkodierung",
  "mathDistribution": "Distribuierung",
  "easy": "einfach",
  "difficultyMiddle": "mittel",
  "difficultyHard": "schwer",
  "sheet": "Blatt",
  "goal": "Ziel",
  "difficultyUC": "Schwierigkeit",
  "bf_infotext_or_interact_with_kv": "Oder interagiere direkt mit dem KV-Diagramm",
  "bf_infotext_kv_must_not_be_empty": "Die Funktion muss Einsstellen und Nullstellen enthalten.<br>Mit ausschließlich 0en oder ausschließlich 1en ist die optimale Umsetzung genau die Funktion, die immer 1, oder immer 0 ausgibt.<br>Da gibt es für uns kaum etwas zu optimieren.",
  "bf_infotext_what_to_do": "Lade eine Übungsaufgabe oder gebe eine Boolesche Funktion mit Hilfe des KV-Diagrams oder der Funktionstabelle ein. Klicke dann auf 'Berechnen' um loszulegen.",
  "bf_infotest_click_on_hidden_areas_to_make_visible": "Klicke auf die versteckten Bereiche, um diese aufzudecken",
  "bf_normal_forms": "Normalformen",
  "bf_disjunctiveNormalForm": "Disjunktive Normalform",
  "bf_conjunctiveNormalForm": "Konjunktive Normalform",
  "bf_disjunctiveMinimalForm": "Disjunktive Minimalform",
  "bf_conjunctiveMinimalForm": "Konjunktive Minimalform",
  "bf_quineMCCluskeyClasses": "Quine McCluskey Klassen",
  "bf_primeTerms": "Primterme",
  "bf_primeImplicants": "Primimplikanten",
  "bf_primeImplicates": "Primimplikate",
  "bf_primeCoverTable": "Überdeckungstabelle",
  "bf_petrickExpression": "Petrick Ausdruck",
  "bf_minimalForms": "Minimalformen",
  "bf_tableWithCyclicRest": "Zyklische Resttabelle",
  "bf_einstelle": "Einsstelle",
  "bf_nullstelle": "Nullstelle",
  "bf_einstellen": "Einsstellen",
  "bf_nullstellen": "Nullstellen",
  "bf_goal_determine_DNF": "DNF bestimmen",
  "bf_goal_determine_KNF": "KNF bestimmen",
  "bf_goal_determine_prime_implicants": "Primimplikanten bestimmen",
  "bf_goal_determine_prime_implicates": "Primimplikate bestimmen",
  "bf_covertable_step_description_initial": "<h4>Initialer Schritt:</h4>Trage spaltenweise alle Basisterme ({ifMinTermsEinstellenElseNullstellen}) und reihenweise alle Primterme (PI) in die Tabelle ein. Überdeckt ein Primterm eine {ifMinTermsEinstelleElseNullstelle}, markiere jene Zelle mit einem X. Die Kosten (eng. cost) c eines Primterms sind die Anzahl seiner Literale. Je höher, desto aufwändiger (teurer) ist die Umsetzung in Hardware. <br>Tipp:<br>Ein PrimimplikaNT überdeckt eine EINstelle genau dann, wenn alle Literale des Primterms auch genauso im Basisterm vorkommen",
  "bf_covertable_step_description_core_found": "<h4>Kern gefunden:</h4>Der einzige Primterm, der die {ifMinTermsEinstelleElseNullstelle} {columnName} überdeckt, ist Term {rowName}. Dieser Primterm muss also unbedingt in unserer Schaltfunktion vorkommen! Markiere die Zeile als Kern und streiche die Spalte heraus.",
  "bf_covertable_step_description_cross_column_bc_covered": "<h4>Spalte bereits abgedeckt:</h4>Die {ifMinTermsEinstellenElseNullstellen} {columnName} wird bereits vom Primterm {rowName} überdeckt. Streiche die Spalte heraus.",
  "bf_covertable_step_description_cross_row_bc_covered": "<h4>Reihe bereits vollständig abgedeckt:</h4>Alle X'e der Zeile {rowName} werden bereits abgedeckt. Streiche die Reihe heraus.",
  "bf_covertable_step_description_row_domination": "<h4>Zeilendominanz:</h4>Die Zeile {dominatorName} dominiert die Zeile {dominatedName}, d.h. {dominatorName} besitzt überall da Markierungen, wo Zeile {dominatedName} auch welche besitzt (und vielleicht sogar mehr). => Streiche die dominieRTE Zeile {dominatedName}. <br>Beachte, dass die Zeilendominanz nur anwendbar ist, da die Zeile {dominatorName} weniger oder genauso viel kostet wie {dominatedName}; bzw. weil es keine andere Zeile gibt, die die zusätzlichen Stellen von {dominatorName} überdeckt und weniger als {dominatorName} - {dominatedName} kostet.",
  "bf_covertable_step_description_column_domination": "<h4>Spaltendominanz:</h4>Die Spalte {dominatorName} dominiert die Spalte {dominatedName}, d.h. {dominatorName} besitzt überall da Markierungen, wo Spalte {dominatedName} auch welche besitzt (und vielleicht sogar mehr). => Streiche die dominieRENDE Spalte {dominatorName}<br>Im Gegensatz zur Zeilendominanz muss bei der Spaltendominanz überhaupt nicht auf Kosten geachtet werden (/▽＼)",
  "bf_covertable_step_description_cyclic_rest": "<h4>Zyklischer Rest:</h4>Keine Regel der Überdeckungstabelle ist anwendbar. Man spricht hierbei von einem 'Zyklischem Rest'.<br>Um nun dennoch eine Minimalform der Schaltfunktion bestimmen zu können, bietet sich eine Aufstellung des Petrick Ausdrucks an, wobei nur Zeilen und Spalten eingetragen werden, die noch nicht herausgestrichen wurden.",
  "bf_infoblob_random_exercise_selection": "Die ausgewählte Schwierigkeit bestimmt dabei, wie viele Terme einer Art (z.B. Minterme, Primimplikanten) die Schaltfunktion enthalten soll.",
  "bf_infoblob_petrick_statement": "Der Algorithmus besteht aus zwei Phasen:<ol><li>Ordne die Terme so um, dass möglichst viel absorbiert wird.</li><li>Multipliziere die Terme aus.</li></ol>",
  "bf_infoblob_load_exercise": "Lade Aufgaben aus den Übungen oder gebe eine Boolesche Funktion ein.<br><br><b>Funktionseingabe:</b><br>Benutze + als logisches ODER<br>Benutze * als logisches UND<br>Benutze ~ als logisches NICHT<br><b>Beispiele:</b><br>a*b+a<br>a*(b+~a)<br>x0*x1+x0*~x1",
  "bf_load_exercise_from_archive": "Lade Aufgabe aus Archiv",
  "bf_error_at_symbol": "Fehler bei Symbol",
  "cmos_error_at_symbol": "Fehler bei Symbol",
  "at_position": "auf Position",
  "cmos_enter_more_than_one_variable": "Bitte gebe mehr als nur eine Variable ein",
  "bf_distributionUC": "Distribution",
  "bf_idempotenceUC": "Idempotenz",
  "bf_absorptionUC": "Absorption",
  "bf_sortingUC": "Sortierung",
  "bf_infoblob_functionMin": "Üben Sie die verschiedenen Verfahren zur Funktionsminimierung",
  "bf_disjunctiveNormalForm_explanation": "Bei der disjunktiven Normalform handelt es sich um eine Disjunktion (Veroderung) aller Minterme (1en) einer Funktion. Jeder Minterm entspricht genau einer 1 in der Funktion; es müssen darin alle Literale negiert oder nicht negiert vorkommen.",
  "bf_conjunctiveNormalForm_explanation": "Bei der konjunktiven Normalform handelt es sich um eine Konjunktion (Verundung) aller Maxterme (0en) einer Funktion. Die 0en werden bei Maxtermen nicht ausgewählt (wie die 1en bei Mintermen), sondern ausgeschlossen. Jeder Maxterm entspricht genau einer 0 in der Funktion; es müssen darin alle Literale negiert oder nicht negiert vorkommen.",
  "bf_quineMCCluskeyClasses_explanation": "Beim Quine/McCluskey Verfahren handelt es sich um ein Minimierungsverfahren, mit welchem die Primterme einer Funktion bestimmt werden können.",
  "bf_infoblob_quineMCCluskeyClasses_colorCoding": "Die reduzierten Terme werden beim Quine/McCluskey Verfahren üblicherweise durch Durchstreichen markiert. Wenn die Farbkodierung aktiv ist, werden sie stattdessen hellgrau eingefärbt. ",
  "bf_infoblob_quineMCCluskeyClasses_01": "Normalerweise schreiben wir die Min-, bzw. Maxterme in die einzelnen Klassen. Es kann alternativ aber auch mit 0en (für negierte Literale) und 1en (für nicht negierte Literale) gearbeitet werden, wobei die Postion dieser bestimmt, um welches Literal es sich handelt.",
  "bf_primeTerms_explanation": "Terme mit minimaler Anzahl an Literalen, die nur Einsstellen bzw. Nullstellen überdecken. ",
  "bf_bf_primeImplicants_explanation": "PrimimplikaNTe sind Primterme, die nur EINstellen (mit Freistellen) überdecken. ",
  "bf_primeImplicates_explanation": "Primimplikate sind Primterme, die nur Nullstellen (mit Freistellen) überdecken. ",
  "bf_disjunctiveMinimalForm_explanation": "Disjunktion von durch Konjunktion verknüpften Literalen. Diese kann (ohne diese Form zu verletzen) nicht weiter vereinfacht werden (vereinfachte DNF).",
  "bf_conjunctiveMinimalForm_explanation": "Konjunktion von durch Disjunktion verknüpften Literalen. Diese kann (ohne diese Form zu verletzen) nicht weiter vereinfacht werden (vereinfachte KNF).",
  "bf_nandnorification": "NAND- / NORisierung",
  "bf_nandification": "NANDisierung",
  "bf_norification": "NORisierung",
  "bf_nandify_double_negation_text": "Doppelt negieren",
  "bf_nandify_nor_to_and_text": "De Morgansche Gesetz (Negation reinziehen)",
  "bf_nandify_redundant_and_text": "Term im AND verdoppeln (x = x*x)",
  "bf_norify_double_negation_text": "Doppelt negieren",
  "bf_norify_nand_to_or_text": "De Morgansche Gesetz (Negation reinziehen)",
  "bf_norify_redundant_or_text": "Term im OR verdoppeln (x = x+x)",
  "cmos_infoblob_description": "Bei CMOS handelt es sich um eine Zusammensetzung aus einem komplementären NMOS-Schaltnetz (Pull-Down-Netzwerk, da mit Erdung verbunden) und PMOS-Schaltnetz (Pull-Up-Netzwerk, da mit Versorgunsspannung verbunden). Dadurch wird im festen Schaltzustand weniger Energie verbraucht, da PDN und PUN komplementär sind und somit nur bei Schalten kurz gleichzeitig leiten. Es wird jedoch mehr Fläche auf dem Chip benötigt.",
  "cmos_infoblob_input_description": "Hinweis: Für ODER-Gatter kann '+' genutzt werden, für UND-Gatter '*' und für die Negation '~'. Variablen können beliebige Namen haben (Achtung: die Eingabe 'ab' wird als eine Variable interpretiert und nicht als Verundung von 'a' und 'b').",
  "enter_cmos": "Bitte geben Sie Ihren CMOS-Eintrag ein.",
  "polyadicExercise2": "vom initialen Format:",
  "newExponent": "Neuer Exponent",
  "systemInBase": "System zur Basis",
  "basis": "Basis",
  "minterms": "Minterme",
  "maxterms": "Maxterme",
  "contact": "Kontakt",
  "impressumText": "Sie finden das Impressum unter: ",
  "and": " und",
  "weThank": "Wir danken den folgenden Personen für ihre Mithilfe beim Erstellen dieser Webseite:",
  "Danksagung": "Danksagung",
  "thankProfessorTeich": "Die Materialien dieser Seite basieren auf der Vorlesung GTI von Professor Dr.-Ing. Jürgen Teich der Friedrich-Alexander-Universität (FAU). Wir danken Ihm für seine Expertise und Schirmherrschaft.",
  "wintersemester": "Wintersemester",
  "sommersemester": "Sommersemester",
  "downloadSvg": "Exportiere SVG",
  "downloadPng": "Exportiere PNG",
  "formula": "Formel",
  "translate_big": "Übersetzen",
  "divByZero": "Division durch 0 ergibt NaN.",
  "falseFormat": "Falsches Format"
}
