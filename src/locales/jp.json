{
  "complementExample": "補完",
  "shiftZero": "シフト後のゼロ",
  "doubleNegative": "マイナス",
  "denormalized": "非正規化",
  "fpExerciseIntro": "「IEEE-754形式の浮動小数点数間の演算を、生成された演習問題で練習する。",
  "fpFormatSelectionSimple": "カスタムフォーマットを選択するには、指数部と仮数部のビット配分を指定します",
  "fpFormatSelection": "カスタムフォーマットを選択するには、まず浮動小数点数のビット数を選択し、次に指数部と仮数部のビット配分を指定します。",
  "fpArithIntro": "IEEE-754に準拠した形式またはそれに基づく自己定義形式の浮動小数点数間の演算の練習",
  "fpConvIntro": "生成された練習問題を用いて、10進法とIEEE-754またはそれに基づく自己定義フォーマットによる浮動小数点数フォーマットとの間の変換練習",
  "polyConvIntro":"自由に選べる位置数体系間の変換練習",
  "polyConvGenIntro": "生成された練習問題を解いて位置数系間の変換を練習する",
  "polyadicMultiplicationDescription": "小数点以下の桁を上から下に読んで余りの桁を求める",
  "polyadicDivisionDescription": "小数点の前の桁は、余りの桁を下から上に読むことによって得られる。",
  "enter_cmos": "CMOSの式を入力してください",
  "sequentialCircuit": "2つのDフリップフロップとマルチプレクサで構成される順次回路の例。",
  "homePageText": "The goal of GTI-Online is to deepen the knowledge of selected topics learned in the lecture and corresponding exercise. Select in the menu a topic and start practicing.",
  "startTraining": "Let's go",
  "numVarInput": "Number of variables",
  "fpExerciseText": "Let \\( fp_1 \\) and \\( fp_2 \\) be given as floating point numbers in 16 bit floating point format. Compute the {op1} \\( fp_1 {op2} fp_2 \\) without leaving the binary representation and specify it again as a floating point number:",
  "confirm": "確認",
  "varNaming": "Variable naming",
  "kvDiagram": "Karnaugh Map",
  "numeralSystem": "Numeral System",
  "polyadic": "Positional numeral system",
  "floatingPoint": "浮動小数点演算",
  "functionMin": "最小化",
  "exercises": "演習",
  "generateEx": "演習を生成する",
  "generate": "生成する",
  "polyFreeIntro": "Practice positional numeral arithmetic with your own numerical values in your desired system.",
  "addition": "追加",
  "subtraction": "引き算",
  "multiplication": "乗算",
  "division": "事業部",
  "solution": "解決方法",
  "ownSolution": "Own 解決方法",
  "signBit": "符号ビット",
  "load": "負荷",
  "correctSolution": "解決方法",
  "exponentBits": "指数",
  "fractionBits": "分数",
  "attRound": "Do not forget to round!",
  "attSolve": "ぜひ、事前に練習問題を解いてみてください",
  "step": "Step",
  "freeCalculation": "Free Calculation",
  "operationSelect": "Configure Computation",
  "firstFloatingPoint": "First Floating Point Number",
  "secondFloatingPoint": "Second Floating Point Number",
  "operand": "Operand",
  "decimal": "Decimal",
  "binary": "Binary",
  "inputNumber": "Input Number",
  "fpformat": "Floating Point Format",
  "check": "Check",
  "values": "Values",
  "arithmetic": "Arithmetic",
  "conversion": "Conversion",
  "conversionExercise": "Exercises for conversion",
  "conversionExercise1": "Convert: ",
  "conversionExercise2": "into a IEEE floating point number with exponent length of ",
  "steps": "steps",
  "repeatMinuend": "repeat\\ minuend",
  "doDivision": "execute division",
  "doMultiplication": "execute multiplication",
  "getDescription": "Print",
  "approach": "Approach",
  "gti": "Foundations of Computer Engineering",
  "disclaimer": "Disclaimer:<br>This is an automatically generated solution approach by the GTI-Online-Website. Every output is completely <u>unofficial</u> and in the drafts state.<br>We are making lots of efforts to build a correct and reliable tool for you. Regardless, there may be failures in the solution or approach. That can especially depend on your browser version. Please review before using it for instance in an exam.",
  "example": "Example",
  "composition": "composition",
  "negativeSummand": "An addition with a negative value is similar to a subtraction.",
  "negativeSubtrahend": "A negative subtrahend is similar to a positive summand.",
  "negativeMinuendSubtrahend": "Simplification for the case \\( - x - y \\rightarrow - (x + y) \\)",
  "addWithZero": "An addition with 0 results in the other summand",
  "subWithZero": "A subtraction with 0 results in the other value",
  "mulWithZero": "A multiplication with 0 results always 0.",
  "zeroDivision": "A division by 0 is illegal!",
  "arithmeticFree": "Free arithmetic",
  "conversionFree": "Free conversion",
  "value": "Value",
  "givenValues": "Values of the transmitted numbers",
  "leftValue": "Left value",
  "rightValue": "Right value",
  "firstSummand": "1. summand",
  "secondSummand": "2. summand",
  "firstFactor": "1. factor",
  "secondFactor": "2. factor",
  "minuend": "Minuend",
  "subtrahend": "Subtrahend",
  "numerator": "Numerator",
  "denominator": "Denominator",
  "sign": "Sign",
  "exponent": "Exponent",
  "adjustExponents": "The exponents of both numbers must be balanced.",
  "addExponents": "The exponents of both numbers must be added.",
  "subtExponents": "The exponents of both numbers must be subtracted.",
  "diffExponent": "Difference of the exponents",
  "smallerExponent": "The smaller exponent will be subtracted from the bigger one.",
  "resDiffExponent": "Hence, this difference is",
  "newExponent": "New exponent",
  "considerExponent": "Consider the exponent",
  "mantissa": "Mantissa",
  "mulMantissa": "The mantissa of both numbers must be multiplied.",
  "solutionIsNan": "The mantissa can not be calculated because the input leads to NaN.",
  "solutionIsInf": "The mantissa can not be calculated because the input leads to infinity.",
  "solutionIsZero": "The mantissa can not be calculated because the input leads to zero.",
  "addMantissa": "The mantissa of both numbers must be added.",
  "divMantissa": "The mantissa of both numbers must be divided.",
  "newMantissa": "New mantissa",
  "zeroMantissa": "both mantissa are equal \\( \\rightarrow \\) the new mantissa is the 0-mantissa",
  "newMantissaIs": "Hence the new mantissa is",
  "equalMantissa": "Both mantissa are equal \\( \\rightarrow \\) the exponent will be incremented the mantissa remains",
  "equalMantissaDiv": "Both mantissa are equal, no binary division will be executed",
  "adjustSmallerMantissa": "Adjust the mantissa",
  "shiftMantissa": "Shift the mantissa",
  "mantissaFloat": "Mantissa inside the float",
  "mantissa1float": "The leading digit is not part of the float",
  "subtTwosComplement": "Subtraction is similar to addition with the two's complement",
  "mantissaTwosComplement": "Formation of the two's complement out of the mantissa",
  "switchBits": "Invert bits",
  "add1": "Add 1",
  "normalize": "Normalize",
  "shiftExpMant": "The exponent's shift factor must be applied to the mantissa.",
  "shift": "Shift",
  "considerRepresentation": "Consider the representation",
  "consider1comma": "The mantissa begins with an 1 in the standard form (and 0 in denormalized form).",
  "ternary": "Ternary system",
  "quaternary": "Quaternary system",
  "quinary": "Quinary system",
  "senary": "Senary system",
  "septenary": "Septenary system",
  "octal": "Octal system",
  "novenary": "Nonal system",
  "hexadecimal": "Hexadecimal system",
  "hex": "Hexadecimal",
  "input": "Input",
  "number": "Number",
  "representation": "representation in original format",
  "firstFormat": "Initial format",
  "secondFormat": "Target format",
  "doConversion": "Convert:",
  "modus": "Mode",
  "to": "to",
  "TenToPower": "The conversion from the decimal system to an arbitrary one goes in two steps. Before the comma, the digits were converted with the use of the division algorithm. After the comma, the multiplication algorithm will be applied.",
  "PowerToTen": "An arbitrary number system can be converted to the decimal system by summarizing all potentiated digits.",
  "PowerToPower": "We convert an arbitrary number system into another within two steps via the decimal system. At first, the original number will be transferred into the decimal system be summarizing the potentiated digits. In the second step, we use the division- and multiplication algorithm to create the resulting number.",
  "noValuesBeforeComma": "There are no values in front of the comma. Therefore, the division algorithm can be skipped.",
  "noValuesAfterComma": "There are no values after the comma. Therefore, the multiplication algorithm can be skipped.",
  "firstToTen": "1. Summation of the potentiated digits",
  "secondToPower": "2. Conversion via division- and multiplication algorithm",
  "shortcutBinToHex": "At the conversion from binary to hexadecimal, the values can be read directly.",
  "shortcutHexToBin": "At the conversion from hexadecimal to binary, the values can be read directly.",
  "divisionAlgorithm": "Division algorithm",
  "multiplicationAlgorithm": "Multiplication algorithm",
  "summation": "Summation",
  "factor": "Factor",
  "quotient": "Quotient",
  "remainder": "Remainder",
  "newBasis": "Base_{'{new}'}",
  "calcStep": "calculation\\ step",
  "summands": "Summands",
  "newMantissaSignBit": "Because of the complement, we calculate with a sign bit:",
  "disclaimerFooter": "No warranty is given for the correctness of the materials provided on this website.",
  "polyadicExercise1": "Convert the value in the",
  "polyadicExercise2": "from the initial format",
  "polyadicExercise3": "to the target format",
  "exerciseArchive": "Exercise Archive",
  "randomExercise": "Random Exercise",
  "doCalculation": "Calculate",
  "colorCoding": "Color coding",
  "mathDistribution": "Distribution",
  "easy": "Easy",
  "difficultyMiddle": "Middle",
  "difficultyHard": "Hard",
  "sheet": "Sheet",
  "goal": "Goal",
  "difficultyUC": "Difficulty",
  "bf_infotext_or_interact_with_kv": "Or directly interact with the KV-Diagram",
  "bf_infotext_kv_must_not_be_empty": "The KV-Diagram must contain 1s and 0s",
  "bf_infotest_click_on_hidden_areas_to_make_visible": "Click on hidden areas to reveal them",
  "bf_normal_forms": "Normal Forms",
  "bf_disjunctiveNormalForm": "Disjunctive normal form",
  "bf_conjunctiveNormalForm": "Conjunctive normal form",
  "bf_disjunctiveMinimalForm": "Disjunctive minimal form",
  "bf_conjunctiveMinimalForm": "Conjunctive minimal form",
  "bf_quineMCCluskeyClasses": "Quine MC Cluskey classes",
  "bf_primeTerms": "Implicants (prime terms)",
  "bf_primeImplicants": "Prime implicants",
  "bf_primeImplicates": "Prime implicates",
  "bf_primeCoverTable": "Prime implicant chart / 'Cover Table'",
  "bf_petrickExpression": "Petrick's method",
  "bf_minimalForms": "Minimal Forms",
  "bf_tableWithCyclicRest": "Table with cyclic rest",
  "bf_einstelle": "One",
  "bf_nullstelle": "Zero",
  "bf_einstellen": "Ones",
  "bf_nullstellen": "Zeros",
  "bf_goal_determine_DNF": "Determine DNF",
  "bf_goal_determine_KNF": "Determine KNF",
  "bf_goal_determine_prime_implicants": "Determine prime implicants",
  "bf_goal_determine_prime_implicates": "Determine prime implicates",
  "bf_covertable_step_description_initial": "<h4>Initial step:</h4>Enter all base terms in the columns and all implicants (PI) in the rows of the table. If a implicant covers a {ifMinTermsEinstelleElseNullstelle}, mark that cell with an X. The cost c of an implicant is the number of its literals. The higher, the more complex (i.e. costly) the implementation in hardware.<br>Tip:<br>A prime implicant covers a 'ONE' exactly if all literals of the implicant also occur in the same way in the base term.",
  "bf_covertable_step_description_core_found": "<h4>Core found:</h4>The only implicant that covers column {columnName} is term {rowName}. Hence this implicant must definitely appear in our resulting function! Mark the row as a 'core' (Kern) and strike out the column.",
  "bf_covertable_step_description_cross_column_bc_covered": "<h4>Column already covered:</h4> Column {columnName} is already being covered by implicant {rowName}. Strike out the column.",
  "bf_covertable_step_description_cross_row_bc_covered": "<h4>Row already covered:</h4>All X's of row {rowName} are already covered. Cross out the row.",
  "bf_covertable_step_description_row_domination": "<h4>Row dominance:</h4>Row {dominatorName} dominates row {dominatedName}; i.e. row {dominatorName} has markers wherever row {dominatedName} does as well (and possibly more!). => cross the dominaTED row {dominatedName}. <br>Note that row dominance is only applicable, because row {dominatorName} costs less than, or the same as {dominatedName}; or because there is no other row that covers the additional markers of {dominatorName} and costs less than {dominatorName} - {dominatedName}.",
  "bf_covertable_step_description_column_domination": "<h4>Column dominance:</h4>Column {dominatorName} dominates column {dominatedName}; i.e. column {dominatorName} has markers wherever column {dominatedName} does as well (and possibly more!). => Cross the dominaTING column {dominatorName}<br>Unlike with row dominance, column dominance doesn't require you to consider costs at all.",
  "bf_covertable_step_description_cyclic_rest": "<h4>Cyclic rest:</h4>No rule of the prime table algorithm is applicable. This is referred to as a 'cyclic rest' (ger: 'Zyklischer Rest').<br>By setting up the Petrick's expression (ger: Petrick Ausdruck) for the rest table, one is still able to determine a minimal form of the original function.",
  "bf_infoblob_random_exercise_selection": "Difficulty states how many individual terms of some kind (e.g. minterms, prime implicants) the boolean function should yield.",
  "bf_infoblob_petrick_statement": "The algorithm consists of two phases:<ol><li>Make terms that absorb each other easily visible through sorting (only shown if it has any effect)</li><li>Multiply the first two terms with each other until the typical sum remains.</li></ol>",
  "bf_distributionUC": "Distribution",
  "bf_idempotenceUC": "Idempotence",
  "bf_absorptionUC": "Absorption",
  "bf_sortingUC": "Sorting",
  "bf_infoblob_functionMin": "On this page you can find different procedures for minimizing boolean expressions.",
  "bf_disjunctiveNormalForm_explanation": "The disjunctive normal form is a disjunction (combination of the terms using or operators) of all minterms (1s) of a function. Each minterm corresponds exactly to a 1 in the function, all literals must occur negated or not negated.",
  "bf_conjunctiveNormalForm_explanation": "The conjunctive normal form is a conjunction (combination of the terms using and operators) of all maxterms (0s) of a function. The 0s are not selected in maxterms (like 1s in minterms), but excluded. Each maxterm corresponds exactly to a 0 in the function, all literals must occur negated or not negated.",
  "bf_quineMCCluskeyClasses_explanation": "The Quine/McCluskey algorithm is a minimization algorithm with which the implicants of a function can be determined.",
  "bf_infoblob_quineMCCluskeyClasses_colorCoding": "All terms used in the reduction are normally crossed out in the Quine/McCluskey algorithm. If color coding is active, they are displayed in light gray instead.",
  "bf_infoblob_quineMCCluskeyClasses_01": "Normally we write the min or max terms into the individual classes. Alternatively, we can also work with 0s (for negated literals) and 1s (for non-negated literals), whereby the position of these determines which literal it is.",
  "bf_primeTerms_explanation": "Terms with a minimum number of literals covering only ones or zeros.",
  "bf_bf_primeImplicants_explanation": "Prime implicants are terms that cover only ones (with don't cares).",
  "bf_primeImplicates_explanation": "Prime implicates are terms which cover only zeros (with don't cares).",
  "bf_disjunctiveMinimalForm_explanation": "Disjunction of literals linked by conjunction, which cannot be further simplified (without violating this form) (simplified DNF).",
  "bf_conjunctiveMinimalForm_explanation": "Conjunction of literals linked by disjunction, which cannot be further simplified (without violating this form) (simplified KNF).",
  "cmos_infoblob_description": "CMOS is a composition of a complementary NMOS  network (pull-down network, since connected to ground) and PMOS network (pull-up network, since connected to supply voltage).\n As a result, less energy is consumed in the fixed switching state, since PDN and PUN are complementary and thus only conduct simultaneously for a short time during switching. However, more area is required on the chip.",
  "cmos_infoblob_input_description": "Note: For OR gates '+' can be used, for AND gates '*' and for negation '~'. Variables can have arbitrary names (Attention: 'ab' is considered as one variable, not as 'a' multiplied by 'b').",
  "contactPersonHeader": "Contact",
  "herausgeber": "Publisher",
  "divWithZero": "For a division with 0 in the numerator, the result is always 0.",
  "impressum": "Imprint",
  "representedByHeader": "Represented by",
  "copyright": "Chair of Computer Science 12, FAU. All rights reserved.",
  "representedBy": "Chair of Computer Science 12 is a public law institution within the Friedrich-Alexander-Universität Erlangen-Nürnberg (FAU). According to Art. 20, 21 BayHSchG, FAU, as a state institution and self-governing body under public law, is represented externally by the President.",
  "haftungsauschlussHeader": "Disclaimer",
  "mantissaComplement": "The mantissa is negative. So we have to form the complement and set the sign bit.",
  "mantissaNormalize": "To make the mantissa start with a leading 1, we need to normalize the mantissa by applying the shift of {shift}. We also have to apply this shift to the exponent, which results in the new exponent {exponent}.",
  "mantissaNormalizeDenorm": "The result cannot be represented in the normalized representation with the shift {shift}, so we use the denormalized representation with the exponent {exponent}.",
  "newExponentDivision": "The new exponent results as \\( E_{'{neu}'} = E_1 - E_2 + BIAS = {E1} - {E2} + {Bias} = {Result} \\)",
  "newExponentMultiplication": "The new exponent results as \\( E_{'{neu}'} = E_1 + E_2 - BIAS = {E1} + {E2} - {Bias} = {Result}\\, ({ExpBits})\\)",
  "haftungsauschlussBody": "The respective institutions are responsible for the content of other websites. All information provided on this website has been compiled and checked to the best of our knowledge and belief. However, we cannot guarantee that the information provided is up-to-date, correct, complete or available at all times. A contractual relationship with the users of the Internet offer does not come about. We are not liable for any damage caused by the use of this internet offer. This exclusion of liability does not apply if the provisions of §839 of the German Civil Code (liability for breach of official duty) are relevant. No liability is accepted for any damage caused by malware or the installation or use of software when calling up or downloading data. As a service provider, we are responsible for our own content on these pages in accordance with § 7 para.1 TMG under the general laws. According to § 8 to 10 TMG we are not obligated to monitor transmitted or stored information or to investigate circumstances that indicate illegal activity. Obligations to remove or block the use of information under the general laws remain unaffected. However, liability in this regard is only possible from the point in time at which a concrete infringement of the law becomes known. If we become aware of any such infringements, we will remove the relevant content immediately. The operator expressly reserves the right to change, supplement or delete individual web pages, web services or the entire offer without separate announcement or to cease publication temporarily or permanently.",
  "systemInBase": "System of base",
  "basis": "Base",
  "minterms": "Minterms",
  "maxterms": "Maxterms",
  "contact": "Contact",
  "impressumText": "The imprint can be found at: ",
  "and": ", and",
  "weThank": "We would like to thank the following people for their help at creating this website:",
  "Danksagung": "Acknowledgement",
  "thankProfessorTeich": "The materials on this page are based on the lecture GTI by Professor Dr.-Ing. Jürgen Teich of the Friedrich-Alexander-University (FAU). We thank him for his expertise and patronage.",
  "wintersemester": "Winter term",
  "sommersemester": "Summer term",
  "downloadSvg": "Export as SVG",
  "downloadPng": "Export as PNG",
  "formula": "Formula",
  "divByZero": "Division by 0 is NaN.",
  "falseFormat": "Wrong format!"
}
